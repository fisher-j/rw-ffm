[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RW-FFM Fuel Analysis",
    "section": "",
    "text": "Preface\nI am going to analyze fuels in 3d for my master’s thesis.\n3d fuel models support the use of 3d, atmospheric-coupled, physics-based fire models. My research focuses on managed redwood forests which, in general have not burned in hundreds of years, but under indigenous management, they burned on average about every 15 years. Fire exclusion, and several cycles of resulting from Euro-american colonization has ostensibly resulted in novel fuel conditions for these systems. Process based models, which can extend to novel conditions could be important to realistically predicing potential fire behavior and building trust surrounding fires re-introduction into these coastal forests. It is assumed that this is a desireable and potentially necesary outcome.\nHerein are the steps I took to model fuels in 3d using data collected from the Jackson Demonstration State Forest in conjunction with the Redwood Fire and Fuels Mitigation thinning experiment, using mostly traditional, field-based fuel sampling techniques."
  },
  {
    "objectID": "ground/ground.html",
    "href": "ground/ground.html",
    "title": "From the ground up",
    "section": "",
    "text": "In odrder to model aerial and surface fuels in 3d, we need to place them on appropriate topography. Topography will affect fire behavior as well as tree placement using the tree placement algorithm, as it affects the spatial locations of crowns and thus their overlap.\nTopographical variables such as slope, aspect, slope position, and land surface curvature may be important for predicting the spatial distribution of fuel loads.\nI will assess topography of our plots/sites visually to determine the best approach for simulating topography for fire simulations and calculate the above mentioned variables for each plot. Transect slope was measured in the field, but I can double check these values using the dem."
  },
  {
    "objectID": "ground/named_and_numbered.html",
    "href": "ground/named_and_numbered.html",
    "title": "Import and wrangle 2d",
    "section": "",
    "text": "First I need to import and wrangle spatial and tabular data. Here I’m going to focus on the 2d, vector data.\n\n\nCode\nlibrary(sf)\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(tmap)\n\n# Load data\nlayers &lt;- \"../data/gis/vector.gpkg\"\nblocks &lt;- st_read(layers, \"Blocks\", as_tibble = TRUE, quiet = TRUE)\nblocks_buffer  &lt;- st_buffer(blocks, 30)\nplot_centers &lt;- st_read(layers, \"Plot_Centers\", as_tibble = TRUE, quiet = TRUE)\n\n# what is the current plot order\npts &lt;- plot_centers |&gt;\n  group_by(THP, Replicate) |&gt;\n  mutate(plotnum = row_number()) |&gt;\n  select(plotnum, THP, Replicate) |&gt;\n  ungroup()\n\ntm_shape(blocks) +\n  tm_borders() +\n  tm_facets(by = c(\"THP_Name\", \"BlockName\")) +\n  tm_shape(pts) +\n  tm_text(size = 1.6, \"plotnum\") +\n  tm_facets(by = c(\"THP\", \"Replicate\"))\n\n\n\n\n\nCode\n# We numbered plots from the top-left to bottom-right, I'll need an algorithm\n# for determing which row a point is on (they don't all have the same\n# y-coorinate)\n\n# I assumed that rows had a similar y coordiante and tried different binning\n# methods until the bins captured the rows correctly\n\nxy &lt;- st_coordinates(plot_centers)\npts &lt;- plot_centers |&gt;\n  bind_cols(xy) |&gt;\n  group_by(THP, Replicate) |&gt;\n  mutate(plotnum = row_number(), .after = \"Replicate\") |&gt;\n  mutate(row = cut_width(Y, 43, center = median(Y), labels = FALSE)) |&gt;\n  arrange(desc(row), plotnum, .by_group = TRUE) |&gt;\n  mutate(plotnum = row_number()) |&gt;\n  select(-c(X, Y, row)) |&gt;\n  ungroup()\n\ntm_shape(blocks) +\n  tm_borders() +\n  tm_facets(by = c(\"THP_Name\", \"BlockName\")) +\n  tm_shape(pts) +\n  tm_text(size = 1.6, \"plotnum\") +\n  tm_facets(by = c(\"THP\", \"Replicate\"))\n\n\n\n\n\nCode\nplot_centers &lt;- pts\n\n# We didn't collect data from all plots. Lets look at entered data and see\n# which plots were used\ncon &lt;- dbConnect(RSQLite::SQLite(), \"../data/rw.db\")\nplots_data &lt;- dbGetQuery(con, \"SELECT * FROM plots\") |&gt; as_tibble()\nplots_data\n\n\n# A tibble: 184 × 8\n   plotid site  treatment burn  plotnum coord_x coord_y notes\n    &lt;int&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;\n 1      1 bob   ls        b          12      NA      NA &lt;NA&gt; \n 2      2 bob   ls        b           3      NA      NA &lt;NA&gt; \n 3      3 bob   ls        b           5      NA      NA &lt;NA&gt; \n 4      4 bob   ls        b           6      NA      NA &lt;NA&gt; \n 5      5 bob   ls        b           9      NA      NA &lt;NA&gt; \n 6      6 bob   ls        nb          1      NA      NA &lt;NA&gt; \n 7      7 bob   ls        nb         12      NA      NA &lt;NA&gt; \n 8      8 bob   ls        nb          3      NA      NA &lt;NA&gt; \n 9      9 bob   ls        nb          6      NA      NA &lt;NA&gt; \n10     10 bob   ls        nb          9      NA      NA &lt;NA&gt; \n# ℹ 174 more rows\n\n\nCode\n# ensure spatial data columns match tabular data\nmake_names_consistent &lt;- function(df, thp_var, replicate_var, ...) {\n  df |&gt;\n    mutate(\n      site = case_when(\n        str_detect({{ thp_var }}, \"Fairbanks\") ~ \"fair\",\n        str_detect({{ thp_var }}, \"Top of\") ~ \"hare\",\n        str_detect({{ thp_var }}, \"Camp 8\") ~ \"camp8\",\n        str_detect({{ thp_var }}, \"Bob\") ~ \"bob\",\n        str_detect({{ thp_var }}, \"Dunlap\") ~ \"dun\",\n        str_detect({{ thp_var }}, \"Cribwall\") ~ \"crib\",\n        TRUE ~ NA_character_\n      ),\n      treatment = str_extract(tolower({{ replicate_var }}), \"ls|m|np\"),\n      burn = str_extract(tolower({{ replicate_var }}), \"b|nb\"),\n      ...\n    ) |&gt;\n    rename(thp = {{ thp_var }}, replicate = {{ replicate_var}})\n}\n\n# The treatment blocks (and blocks buffer) should also use this naming\n# convention\nblocks &lt;- make_names_consistent(\n  blocks,\n  THP_Name,\n  BlockName,\n  .after = \"BlockName\"\n)\nblocks_buffer &lt;- make_names_consistent(\n  blocks_buffer,\n  THP_Name,\n  BlockName,\n  .after = \"BlockName\"\n)\nplot_centers &lt;- make_names_consistent(\n  plot_centers,\n  THP,\n  Replicate,\n  .after = \"plotnum\"\n)\n\n\n# spatial data should include plotids from tabular data\nplot_centers &lt;- left_join(\n  plot_centers,\n  select(plots_data, any_of(c(names(plot_centers), \"plotid\")))\n) |&gt;\n  relocate(plotid)\n\n# Now I could insert the plot center coordiates into the tabular data but I\n# think that for now, it is fine to have tabular and spatial data stored\n# separately, they can easily be combined when loaded.\n\n# data_to_insert &lt;- select(plot_centers, X, Y, plotid) |&gt;\n#   st_drop_geometry() |&gt;\n#   tidyr::drop_na() |&gt;\n#   as.list() |&gt;\n#   unname()\n#\n# dbExecute(\n#   con,\n#   \"UPDATE plots SET coord_x = ?, coord_y = ? WHERE plotid = ?\",\n#   params = data_to_insert\n# )\n\n# our plots were 11.28 meters in diameter\nplot_discs &lt;- st_buffer(plot_centers, 11.28)\n\ntmap_mode(\"view\")\nmap_kinds &lt;- c(\"Esri.WorldTopoMap\", \"Esri.WorldImagery\")\ntmap_options(basemaps = map_kinds)\ntm_shape(blocks) +\n  tm_borders(col = \"red\", lwd = 1.4) +\n  tm_shape(plot_discs) +\n  tm_borders(col = \"red\", lwd = 1.4) +\n  tm_text(col = \"red\", size = 1.6, \"plotnum\")\n\n\n\n\n\n\nCode\n# # as a last step, I'll write the plot number data back to a new database. \n# # This is commented out so it doesn't get written each time it's run\nnamed_numbered &lt;- \"../data/gis/named_numbered.gpkg\"\n\nst_write(\n  st_transform(plot_centers, st_crs(26910)),\n  named_numbered,\n  \"plot_centers\",\n  append = FALSE\n)\n\n\nDeleting layer `plot_centers' using driver `GPKG'\nWriting layer `plot_centers' to data source \n  `../data/gis/named_numbered.gpkg' using driver `GPKG'\nWriting 445 features with 8 fields and geometry type Point.\n\n\nCode\nst_write(\n  st_transform(blocks, st_crs(26910)),\n  named_numbered,\n  \"blocks\",\n  append = FALSE\n)\n\n\nDeleting layer `blocks' using driver `GPKG'\nWriting layer `blocks' to data source \n  `../data/gis/named_numbered.gpkg' using driver `GPKG'\nWriting 36 features with 6 fields and geometry type Multi Polygon.\n\n\nCode\nst_write(\n  st_transform(blocks_buffer, st_crs(26910)),\n  named_numbered,\n  \"blocks_buffer\",\n  append = FALSE\n)\n\n\nDeleting layer `blocks_buffer' using driver `GPKG'\nWriting layer `blocks_buffer' to data source \n  `../data/gis/named_numbered.gpkg' using driver `GPKG'\nWriting 36 features with 6 fields and geometry type Polygon.\n\n\nCode\ndbDisconnect(con)"
  },
  {
    "objectID": "ground/visualize_3d.html",
    "href": "ground/visualize_3d.html",
    "title": "Import and visualize 3d",
    "section": "",
    "text": "Now that I have plot points and treatment boundaries all defined with consistent naming, I can visualize a 3d model of our topography and determine a strategy for extracting topograpical variables and simulating representative topogrphy for fire simulation.\n\n\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(stars)\nlibrary(rayshader)\n\nrgl::setupKnitr(autoprint = FALSE)\n\n# I want to overlay my plots on a 3d surface representing the terrain for each\n# site\naerial_files &lt;- list.files(\"../data/gis/EE_naip_jdsf\", full.names = TRUE, pattern = \".tif$\")\ndem_files &lt;- list.files(\"../data/gis/usgs_1m_dem\", full.names = TRUE, pattern = \".tif$\")\n\naerial &lt;- st_mosaic(aerial_files) |&gt; read_stars()\ndem &lt;- st_mosaic(dem_files) |&gt; read_stars()\n\nvect_db &lt;- \"../data/gis/named_numbered.gpkg\"\nblocks_buffer &lt;- st_read(vect_db, \"blocks_buffer\", as_tibble = TRUE, quiet = TRUE)\nblocks &lt;- st_read(vect_db, \"blocks\", as_tibble = TRUE, quiet = TRUE)\nplot_centers &lt;- st_read(vect_db, \"plot_centers\", as_tibble = TRUE, quiet = TRUE)\nplot_discs &lt;- st_buffer(plot_centers, 11.28)\n\n# try it out with one block\noneblock &lt;- filter(blocks, site == \"camp8\", treatment == \"ls\", burn == \"b\")\noneplots &lt;- filter(plot_discs, site == \"camp8\", treatment == \"ls\", burn == \"b\")\nonecenters &lt;- filter(plot_centers, site == \"camp8\", treatment == \"ls\", burn == \"b\")\noneraster &lt;- dem[oneblock]\noneimage &lt;- aerial[oneblock]\n\ndem_matrix &lt;- st_as_stars(oneraster)[[1]]\n\n# Get actual data for 3 bands scaled to [0,1], and transposed like rayrender\n# likes it. colors stretched to data range to brighten\naerial_array &lt;- st_as_stars(oneimage) |&gt;\n  slice(band, 1:3) |&gt;\n  pull() |&gt;\n  (`/`)(255) |&gt;\n  scales::rescale(to = c(0, 1)) |&gt;\n  aperm(c(2, 1, 3))\n\ndata_plots &lt;- oneplots |&gt; filter(!is.na(plotid))\nplots_overlay &lt;- rayshader::generate_line_overlay(\n  st_cast(data_plots, \"MULTILINESTRING\"),\n  extent = st_bbox(oneraster),\n  heightmap = dem_matrix,\n  color = \"red\"\n)\nrw_texture &lt;- create_texture(\"#bca5a1\", \"#bf754e\", \"#6a3b1e\", \"#bf754e\", \"#daaa75\")\n\naerial_array |&gt; \n  add_overlay(plots_overlay) |&gt;\n  plot_3d(dem_matrix)\n\nrgl::rglwidget()\n\n\n\n\n\n\nCode\n# dem_matrix |&gt;\n#   sphere_shade(texture = rw_texture) |&gt;\n#   add_overlay(plots_overlay) |&gt;\n#   plot_3d(dem_matrix)\n\nbb &lt;- st_bbox(oneraster)\ndeltay &lt;- bb[4] - bb[2]\ny_offset &lt;- (1 - 200 / deltay) / 2 \ndem_matrix |&gt;\n  sphere_shade(texture = rw_texture) |&gt;\n  add_shadow(texture_shade(dem_matrix)) |&gt;\n  add_shadow(lamb_shade(dem_matrix), max_darken = 0.2) |&gt;\n  add_overlay(plots_overlay) |&gt;\n  plot_3d(dem_matrix)\nrender_compass(position = \"S\", altitude = min(dem_matrix, na.rm = TRUE))\nrender_scalebar(\n  limits = c(0, 200),\n  scale_length = c(y_offset, 1 - y_offset),\n  y = min(dem_matrix, na.rm = TRUE),\n  label_unit = \"m\"\n)\nrender_camera(theta = 300, phi = 25, fov = 60, zoom = 0.8)\n\ndata_centers &lt;- onecenters |&gt; filter(!is.na(plotid))\nfor (i in seq_len(nrow(data_centers))) {\n  render_label(\n    dem_matrix,\n    text = as.character(data_centers[i, \"plotnum\", drop = TRUE]),\n    lat = st_coordinates(data_centers)[i, 2],\n    long = st_coordinates(data_centers)[i, 1],\n    altitude = 10,\n    extent = st_bbox(oneraster),\n    linewidth = 1\n  )\n}\n\nrgl::rglwidget()"
  }
]